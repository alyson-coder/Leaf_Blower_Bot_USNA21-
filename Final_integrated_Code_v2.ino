// This CODE will run the rangefinder function as a ticker object and print/return // a distance value every X seconds. When between a specified distance in front of the // vehicle will stop, reverse, and turn right then continue moving forward. The obstacle // avoidance should run concurrently with the path planning for the robot// NOTE: This is the version2 code, we were trying to trouble shoot certain timing issues // with the path-planning but it is NOT FINISHED//#include <Servo.h>#include <Ticker.h>#define trigPin 3 //pwm pin#define echoPin 2                       // 100mS set timer duration in microseconds // Initialize Servo Object //Servo servo1; int joint1 = 0;int i = 100;int k = 2; // MOTOR A -Rightconst int in1 = 7 ; //IN1 -> pin7const int in2 = 8 ; //IN2 -> pin8const int pwmA = 9 ; //EN1 -> pin6 (pwm enable line)// MOTOR B -Leftconst int in3 = 12; //IN3 -> pin12const int in4 = 13; //IN4 -> pin13const int pwmB = 11; //EN2 -> pin11 (pwm enable line)// Global Variables float duration, distance;float range = 0;  int run_num = 1;  // The value will quickly become too large for an int to store therefore store time// values as an unsigned long intunsigned long previousMillis = 0; unsigned long currentMillis = 0; unsigned long interruptMillis = 0; unsigned long interruptTime = 0; // constants won't change :const long interval = 5000;// Functions Declarationsvoid range_finder(); void drivestraight(); void reverse();void CW90_turn();void CC90_turn();void CC180_turn(); void CW180_turn(); void turnoff(); void avoid_obstacle(); //void rotate_servo(); // Declare Ticker ObjectTicker tickerObject(range_finder, 25); //Ticker ticker_Servo(rotate_servo, 50); // For providing logic to L298 IC to choose the direction of the DC motor// Before starting, HERE ARE SOME NOTES: //   1) Stalls at speeds less than 50void setup() {    // Attach the rangefinder     pinMode(trigPin, OUTPUT);   pinMode(echoPin, INPUT);  // Attach the Servo   //servo1.attach(5);   // Attach the Motor Control Pins    // LEFT      pinMode(in1,OUTPUT) ; // we have to set PWM pin as output   pinMode(in2,OUTPUT) ;   // RIGHT    pinMode(in3,OUTPUT) ;   pinMode(in4,OUTPUT) ;    // Enable Pins   pinMode(pwmA,OUTPUT) ; // LEFT Motors    pinMode(pwmB,OUTPUT) ; // RIGHT Motors //Logic pins are also set as output     Serial.begin (9600); // DEFINE THE BAUD RATE HERE<--------     // Start Ticker Objects   tickerObject.start(); //start the ticker.  // ticker_Servo.start(); }void loop(){  // this function will run the motors in both directions at a fixed speed  unsigned long currentMillis = millis();    avoid_obstacle(); //RUN MY OBSTACLE AVOIDANCE FUNTION     // Update values associated with ticker functions   tickerObject.update(); //range_finder()  //ticker_Servo.update(); // servo_rotate()    // Reset Time in the following loop  interruptMillis = 0;   interruptTime = 0;    if (currentMillis + (previousMillis + interruptTime) >= interval) {    // Age the Variable so it runs every 5 seconds(interval)    previousMillis = currentMillis;    // This portion is essentially counting the number of legs(runs)    // so if at the end of the first leg the robot will turn around CC    // and if at the end of and even number leg the robot will turn around CW    if ((run_num % 2) == 0){     // Turn to the Right 180 degrees     CW180_turn();     run_num = run_num + 1; //If it goes to an even leg, add a number to the run count once finished     delay(800);    }    else{     CC180_turn();     run_num = run_num + 1; //If it's on an odd leg, add a number to the run count once finished     delay(800);         }     }       } // END MAIN LOOP// -------------------------- FUNCTIONS BELOW------------------------// Range Finder Function void range_finder(){  //Declare Local Float  float range_old = 0;    // Attach the rangefinder   digitalWrite(trigPin, LOW);   delayMicroseconds(2);   digitalWrite(trigPin, HIGH);  delayMicroseconds(10);  digitalWrite(trigPin, LOW);    duration = pulseIn(echoPin, HIGH);  distance = (duration / 2) * 0.0344;    // Create a filter essentially  range = (range_old*.2) + (distance*0.8);     return range;  // Age Variables   range_old = range;}  // Drive Straight Forward ------------------------------ void drivestraight(){  // turn on motor A  digitalWrite(in1, HIGH);  digitalWrite(in2, LOW);  // set speed to 200 out of possible range 0~255  analogWrite(pwmA, 70); //125);   // turn on motor B  digitalWrite(in3, HIGH);  digitalWrite(in4, LOW);  // set speed to 200 out of possible range 0~255  analogWrite(pwmB, 70); //80); }  // Reverse Motor Directionvoid reverse(){  // turn on motor A  digitalWrite(in1, LOW);  digitalWrite(in2, HIGH);  // set speed to 200 out of possible range 0~255  analogWrite(pwmA, 70); //125);   // turn on motor B  digitalWrite(in3, LOW);  digitalWrite(in4, HIGH);  // set speed to 200 out of possible range 0~255  analogWrite(pwmB, 70); //80); }    // Turn 90 degrees (CW)  --------------------- void CC90_turn(){    //delay 800 ms for 90 degree turn  //servo1.write(100); // lock servo facing front  // Motor A  digitalWrite(in1, HIGH);  digitalWrite(in2, LOW);  // set speed to 200 out of possible range 0~255  analogWrite(pwmA, 100); //125   // Motor B  digitalWrite(in3, LOW);  digitalWrite(in4, HIGH);  // set speed to 200 out of possible range 0~255  analogWrite(pwmB, 100); //80    }     // Turn 90 degrees (CC)  --------------------- void CW90_turn(){    //delay 800 ms for 90 degree turn  //servo1.write(100); // lock servo facing front  // Motor A  digitalWrite(in1, LOW);  digitalWrite(in2, HIGH);  // set speed to 200 out of possible range 0~255  analogWrite(pwmA, 100); //125   // Motor B  digitalWrite(in3, HIGH);  digitalWrite(in4, LOW);  // set speed to 200 out of possible range 0~255  analogWrite(pwmB, 100); //80 }   // Turn 180 degrees (CC)  --------------------- void CC180_turn(){    //delay 800 ms in main loop  // Motor A  digitalWrite(in1, HIGH);  digitalWrite(in2, LOW);  // possible range 0~255  analogWrite(pwmA, 190);    // Motor B  digitalWrite(in3, LOW);  digitalWrite(in4, HIGH);  // possible range 0~255  analogWrite(pwmB, 100);     }     // Turn 180 degrees (CW)  --------------------- void CW180_turn(){    //delay 800 ms for 90 degree turn     // Motor A  digitalWrite(in1, LOW);  digitalWrite(in2, HIGH);  // possible range 0~255  analogWrite(pwmA, 100);   // Motor B  digitalWrite(in3, HIGH);  digitalWrite(in4, LOW);  analogWrite(pwmB, 180);    }     // Turn off motors ------------------------------------------  void turnoff(){  //servo1.write(100); // lock servo facing front  digitalWrite(in1, LOW);  digitalWrite(in2, LOW);    digitalWrite(in3, LOW);  digitalWrite(in4, LOW);}void avoid_obstacle(){  // Avoid Obstacle ----------------------------------------------  // This if statement set the motors to off if an object is detected, otherwise motors   // will be set to on  if (25 <= range && range <=50){     Serial.print("Distance = ");     Serial.print(range);     Serial.println(" | Object Detected!");  // I need to count how long the vehicle runs in the avoid_obstacle loop   // in order to standardize the time each leg takes for the path planning portion  unsigned long interruptMillis = millis();  turnoff();   reverse();  delay(100); // Delays allow time to for the vehicle to complete the action before it reverse()  CC90_turn();  delay(250); // The turn rate is slower when coming from the reverse direction    // Counting up how much time has been spent in this if statement portion  interruptTime = interruptMillis;   //return interruptTime; // Return the time in the if statement    }    else{  // Drive Straight Forward for X seconds   drivestraight();     Serial.print("Distance = ");   Serial.print(range);   Serial.println(" cm");  }}//void rotate_servo(){//  servo1.write(i);  // if (i == 140){  //     k = -1;    //   }  //   if(i == 70){  //   k= 1;  //   }  //   i = i + k;   //   }